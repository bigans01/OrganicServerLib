#pragma once

#ifndef BPMASSMANAGERV2_H
#define BPMASSMANAGERV2_H

#include "ECBMap.h"
#include "ForgedPolySet.h"
#include "OperableIntSet.h"
#include "ForgedPolyRegistry.h"
#include "OrganicClient.h"
#include "ContouredPlanV2Base.h"
#include "ECBPolyReformer.h"

/*

Description:

This class is functionally the same as BlueprintMassManager, save for the fact that it is designed to work with ContourPlanV2Base instances,
and not ContourBase instances.

*/

class BPMassManagerV2
{
	public:
		BPMassManagerV2() {};

		BPMassManagerV2(ECBMap* in_managerEcbMapRef,
			OrganicClient* in_organicClientRef,
			ContouredPlanV2Base* in_contourPlanRef) :
				managerEcbMapRef(in_managerEcbMapRef),
				organicClientRef(in_organicClientRef),
				contourPlanRef(in_contourPlanRef)
		{};

		void buildContouredMass();	// Build the mass generated by the referenced ContourPlanV2Base; 
									// this is a stand-alone, independent mass that exists in its own mass-space (separate from the server-side world mass-space)

		void buildPersistentMasses();		// build persistent masses for any blueprints found to exist on the server, that also exist in the ContourPlan.
		OrganicTriangleTracker* getReformerTrackerRef(EnclaveKeyDef::EnclaveKey in_blueprintKey);	// gets a reference to the OrganicTriangleTracker instance, that exists at the key value EnclaveKey,
																									// in the reformerTracker map of this class; this is needed to track OREs that are modified, when 
																									// calling the virtual runMassDrivers function on a ContourPlanV2Base instance.
		void scanForDissolvableTriangles();		// scans for OrganicTriangles to dissolve in the underlying reformerTracker, by determine OREs 
												// that are touched by OrganicTriangles in BOTH the persistened and contoured masses.

		void updatePersistentBlueprintPolys();	// updates the persistent mass with new ECBPolys, and deletes old ones that need to be deleted because they were dissolved.
	private:
		ECBMap* managerEcbMapRef = nullptr;		// a reference to the calling instance of OrganicServer's ECBMap.

		ContouredPlanV2Base* contourPlanRef = nullptr;	// a reference to the ContourPlanV2Base that this instance will interact with; must be set by constructor.
		OrganicClient* organicClientRef = nullptr;		// a reference to an instance of OrganicClient, so that this instance may interface with an underlying OrganicSystem.

		ECBMap contouredPlanMass;	
		ForgedPolyRegistry contouredPlanEntireShellRegistry;	// all ECBPoly instances need to be stored here; this required for ORE production, which is needed before any mass driving is attempted.
		ForgedPolyRegistry contouredPlanMassDriverRegistry;		// any ECBPoly that has an ECBPolyType::SHELL_MASSDRIVER needs to go here.

		std::unordered_map<EnclaveKeyDef::EnclaveKey, OperableIntSet, EnclaveKeyDef::KeyHasher> contouredPlanShellBlueprintKeyAndSetPairs;	// keeps track of the IDs of all ECBPolys that the 
																																			// referenced contourPlanRef produced

		ECBMap persistentMass;	// the mass for what exists on the server, before the contour plan adds anything.

		std::unordered_map<EnclaveKeyDef::EnclaveKey, ECBPolyReformer, EnclaveKeyDef::KeyHasher> reformerTracker;

		void buildContourMassShell();		// build a mass shell, based off the shell spolys that the referenced contour plan produced.
		void produceOREsForShellPolys();	// produce the OREs, for all ECBPolys contained within the contouredPlanShellBlueprintKeyAndSetPairs member, but putting them into
											// the contouredPlanMass (a member of this class) for production (so not the managerEcbMapRef)
		void runMassDriversForIndependentMass();	// run the mass driving sequence for all of the ECBPolys (and the OREs we produced) for the contouredPlanMass.

		// copy the ECBPolys that were added by the referenced ContourPlan to a specific existing blueprint, into this BlueprintMassManager instance.
		void copyMassShellPolysFromServerToMass(EnclaveKeyDef::EnclaveKey in_blueprintKey, OperableIntSet in_contourAddedOrganicTrianglesSet);
};

#endif